import argparse
import model_evolution
import data_parser
import datetime
import json
import collections

MONTH_TO_INDEX = {
        "january": 1,
        "jan": 1,
        "february": 2,
        "feb": 2,
        "march": 3,
        "mar": 3,
        "april": 4,
        "apr": 4,
        "may": 5,
        "june": 6,
        "jun": 6,
        "july": 7,
        "jul": 7,
        "august": 8,
        "aug": 8,
        "september": 9,
        'sep': 9,
        "sept": 9,
        "october": 10,
        "oct": 10,
        "november": 11,
        "nov": 11,
        "december": 12,
        "dec": 12,
}

MONTH_TO_NAME = [None, "january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"]

def GetInterconnectByMonth(start_month, end_month, census_tract_level, states):
    marshal_files_by_month = {}
    for i in range(start_month, end_month+1):
        if census_tract_level:
            marshal_files_by_month[i] = ["data/computed_interconnect/{}/{}.marshal".format(MONTH_TO_NAME[i], state) for state in states]
        else:
            marshal_files_by_month[i] = ["data/computed_county_interconnect/{}/{}.marshal".format(MONTH_TO_NAME[i], state) for state in states]

    return data_parser.LoadMonthlyMarshalInterconnect(marshal_files_by_month)


def GetTransmission(interconnect, transmission_params, month):
    unadjusted = sum(v.transmission * transmission_params.beta_by_category.get(k, 0) for k,v in interconnect.category_map.iteritems()) + transmission_params.internal_transmission
    return unadjusted * transmission_params.monthly_factor.get(month, 1.0)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument("start_month", help="Required: The month to start the simulation")
    parser.add_argument("end_month", help="Required: The month to end the simulation (inclusive)")
    parser.add_argument("state", help="Required: The state to run the simulation for")
    parser.add_argument("transmission_params", help="""Required: A json formatted specification of the transmission params. Must match what is generated by TransmissionParameters.AsDict()""")
    parser.add_argument("--census_tract_level", help="""If specified compute based on census tract instead of county level (slower).""",  default=False, type=bool)

    args = parser.parse_args()

    start_month = MONTH_TO_INDEX[args.start_month]
    end_month = MONTH_TO_INDEX[args.end_month]

    start_date = datetime.datetime(2020, start_month, 1)
    if end_month == 12:
        end_date = datetime.datetime(2021, 1, 1)
    else:
        end_date = datetime.datetime(2020, end_month + 1, 1)
    states = args.state.split(',')

    print("Loading monthly interconnect")

    interconnect_by_month = GetInterconnectByMonth(MONTH_TO_INDEX[args.start_month], MONTH_TO_INDEX[args.end_month], args.census_tract_level, states)

    raw_params = json.loads(args.transmission_params)
    new_factors = {}
    for month, val in raw_params['monthly_factors'].items():
        new_factors[MONTH_TO_INDEX[month.lower()]] = val
    raw_params['monthly_factors'] = new_factors
    transmission_params = model_evolution.TransmissionParamsFromDict(raw_params)

    print("Loading population and disease estimate data")
    pop_by_county = data_parser.LoadPopulationByCounty("data/county_pops.pickle")
    disease_stats = data_parser.LoadRawDiseaseStats("data/county_estimates.pickle")

    transmission_by_block_month = {}
    for month, interconnect in interconnect_by_month.iteritems():
        for interconnect_block in interconnect:
            transmission_by_block_month[(month, interconnect_block.block)] = GetTransmission(interconnect_block, transmission_params, month)

    evaluation_intervals = None

    computed_blocks, error = model_evolution.RunScenario(pop_by_county, disease_stats, start_date, end_date, interconnect_by_month, transmission_params, evaluation_intervals)


    print("Overall Error: {}".format(error))

    stats_by_county_date = collections.defaultdict(dict)
    county_pops = {}
    for date, blocks_for_date in sorted(computed_blocks.iteritems()):
        stats_by_county = model_evolution.GetStatsByCounty(blocks_for_date)
        for i in range(len(blocks_for_date.block_counties)):
            county = blocks_for_date.block_counties[i]
            actual_ever_sick, _ = data_parser.ExtractStats(disease_stats.get(county), date, model_evolution.INFECTION_DURATION)
            current_pop, current_ever_sick, _ = stats_by_county_date[county].get(date, (0, 0, 0))
            stats_by_county_date[county][date] = (current_pop + blocks_for_date.populations[i], current_ever_sick + (blocks_for_date.populations[i] - blocks_for_date.susceptible[i]), actual_ever_sick)
            county_pops[county] = current_pop + blocks_for_date.populations[i]





    header = ["County", "Population"]
    rows = []

    for date in sorted(computed_blocks.keys()):
        header.append("{} - Predicted".format(date.strftime("%Y/%m/%d")))
        header.append("{} - Actual".format(date.strftime("%Y/%m/%d")))
        header.append("{} - Ratio".format(date.strftime("%Y/%m/%d")))

    for county, county_stats_by_date in stats_by_county_date.iteritems():
        row = [county, county_pops[county]]

        for date in sorted(computed_blocks.keys()):
            pop, predicted, actual = county_stats_by_date[date]
            row.append(predicted)
            row.append(actual)
            row.append(predicted / actual)
        rows.append(row)

    print(",".join(header))
    print("\n".join([",".join([str(x) for x in row]) for row in rows]))
